# UBIT test

The application can be reached on this url: [UBIT test](https://ubittest.jeppan875.now.sh/)

## Frontend

- Next JS
- Styled components
- Redux
- Sagas

#### NextJs

React framework for server rendering. Disable javascript in settings > debugger and see each page render without any javascript execution.

NextJs looks in the pages directory for existing pages. Index.js is the home route. This application has the / home route and article/slug. By making directory article and a file in brackets \[slug].js
we can create dynamic pages based on a slug. So each article can be reach by their slug.

The rest is quite similar ordinary react.

#### Redux

I choosed to use redux for state handling. It is a lot of overhead but tend to work out fine as project scales.

#### sagas

For handling side effects like fetching data. I find this a convinient place to handle fetching and
populating the redux state by calling actions that calls reducers. Sagas come with many handy functions that can be helpful for handling side effects. For instance the most used TakeLatest which always take the latest request. So if another request was sent before the other had chance to complete it cancels the previous saga.

#### styled components

[styled components](https://styled-components.com/)
I came to like this a lot since it is quite easy to work with and understand. You can easily send props to styled components which can be used for dynamically render the css.

#### Structure

Each page has its own page file defined in the pages folder. In the containers folder each page has its own folder. Here they have their sagas, actions, selectors, reducers and constants files. They also have a components folser for components specific for this page only.

Components folders holds components that are shared throughout the application.

## Backend

- Lambdas
- dynamodb
- now

#### Lambdas

Nextjs comes with a built in feature for creating serverless lambdas. By making a folder in the pages directory called api each file there becomes a lambda function. There is one file ther called articles.js which handles get, post and delete requests. In apiLib directory I have creted the functions for handling each request plus validation schema with Joi.

Endpoints:

POST api/articles
GET api/articles, api/articles?slug=slug
DELETE api/articles?slug=slug

#### dynamodb

I choosed aws dynamodb for database. There is one table called articles which holds the following properties:

slug: autogenerated (primary key)
createdAt: autogenerated
title: string
text: string
author: string
authorImg: string
imgurl: string

Dynamodb has a feature called global indexes where you can define indexes for your tables. I creted one called list-article-index which only retrieves the properties needed for displaying an article in al list. Only slug, imgurl and title are retrieved from here.

#### now

[zeit now](https://zeit.co/)
I use now for deploying the application.

#### caching

[zeit edge caching](https://zeit.co/docs/v2/serverless-functions/edge-caching)
zeit now comes with its own caching where content can be cached at their cdn.
For the frontpage articles I use cache control stale-while-revalidate:

Cache-Control: s-maxage=1, stale-while-revalidate

To see it in action go to frontpage and look at x-now-cache header after reloading:
x-now-cache: MISS // the response is came from origin server and not cdn, only happens after a new deploy
reload page
x-now-cache: STALE // the response is stale and served from cdn, in the background a new request to origin server is done to get a fresh copy
create a new article and reload
x-now-cache: STALE // the response is stale and served from cdn, no changes are shown but the cache will get updated after getting a new copy from the server.
reload again
x-now-cache: STALE // you will see a new cached copy.

For the seperate articles I use a time based cache. Here it is set for 1 min just for showing how it works.
Cache-Control: s-maxage=1

reload page
x-now-cache: MISS // no cache
reload page
x-now-cache: HIT // serve from cache
wait 1 min reload
x-now-cache: MISS // no cache

In reality you probably want to cache this for a long time since the articles probably not change after they are published. There seem to be some limitation on zeit for purging a cache by url which others also raised [issue](https://github.com/zeit/docs/issues/1617) on. Especially for cms where you might want to update an article becuase of some typo would want to invalidate the cache.
